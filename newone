#include <stdio.h>
#include <iostream>
#include <cv.h>
#include <highgui.h>
#include <math.h>


using namespace std;
    
	
	
void separation2(IplImage *, IplImage *,int);
void judeg(IplImage *,double *,double *,double*,double *,double ,int);
void imagedepth(double ,double *,int);
int main()
{   
	int IW;
    int IL;
	int choose=1;//選擇顏色
	int correctchoose=0;
	double x,y,z;
	double side[9]={0};
	double sideofimage=0;
	IplImage *Img;
	IplImage *dst;
	Img = cvLoadImage("testpicture2.jpg",1); 
	IW = Img->height;
    IL = Img->width;
    dst= cvCreateImage( cvSize(IL ,IW) , 8, 1 );
	for(int i=0; i<5;i++){
		separation2(Img,dst,choose);//提取顏色
  		judeg(dst,&x,&y,&z,&side[i],0,choose);//找重心
	if( side[i] > side[i-1] )
	{
	  correctchoose=choose;
	}
	  choose++;
	}
	separation2(Img,dst,correctchoose);//提取顏色
	imagedepth(side[correctchoose],&sideofimage,choose);
	judeg(dst,&x,&y,&z,&side[correctchoose],sideofimage,correctchoose);//找X和Y
	cout << correctchoose << "\n";
	cout << "x:" << x << "    y:" << y  << "     z:" << z;
	system ("pause");
}
void imagedepth(double sidelength, double *sideofimage,int choose)
{
	double realobjectdistance = 34;
	int scalevalue=0;
	int side;
	if(choose==1)
		scalevalue=8;
	else
		scalevalue=15;
	side = sidelength;
	*sideofimage=realobjectdistance*side/scalevalue;
}
void separation2(IplImage *src, IplImage *dst, int a){
  //陣列方式宣告
	//unsigned char** R = new unsigned char *[src->height];	
	//unsigned char** G = new unsigned char *[src->height];
	//unsigned char** B = new unsigned char *[src->height];
	//for( int i = 0 ; i < src->height ; i++ ){
	//	R[i] = new unsigned char[src->width];
	//	G[i] = new unsigned char[src->width];
	//	B[i] = new unsigned char[src->width];
	//}
//指標方式宣告
	IplImage *R = cvCreateImage(cvGetSize(src),8,1);
	IplImage *G = cvCreateImage(cvGetSize(src),8,1);
	IplImage *B = cvCreateImage(cvGetSize(src),8,1);
	for( int i=0 ; i<src->height ; i++ ){
		int countR=0,countG=0,countB=0;
		for ( int j=0; j<src->widthStep ; j++ ){
			if	( j%3==2 ){
				R->imageData[i*R->width+countR]= src->imageData[i*src->widthStep+j];
				countR++;
			}
			if ( j%3==1 ){
				G->imageData[i*G->width+countG]= src->imageData[i*src->widthStep+j];
				countG++;
			}
			if ( j%3==0 ){
				B->imageData[i*B->width+countB]= src->imageData[i*src->widthStep+j];
				countB++;
			}
		}
	}
//RGB矩陣測試
	for( int i=0 ; i<src->height ; i++ ){
		for(int j=0 ; j<src->width ; j++){
			unsigned char temp=B->imageData[i*B->width+j];
			unsigned char temp1=G->imageData[i*G->width+j];
			unsigned char temp2=R->imageData[i*R->width+j];
			int t = temp;
			int t1=temp1;
			int t2=temp2;
		}
	}
	for( int i=0 ; i<dst->height ; i++ ){
		for( int j=0 ; j< dst->width ; j++ ){
			for(int k=0 ; k<3 ; k++){
				unsigned char temp=B->imageData[i*B->width+j];
				unsigned char temp1=G->imageData[i*G->width+j];
				unsigned char temp2=R->imageData[i*R->width+j];
				int t=temp;
				int t1=temp1;
				int t2=temp2;
				if(t>128)
				t=255;
				else
					t=0;
				if(t1>128)
					t1=255;
				else
					t1=0;
				if(t2>128)
					t2=255;
				else
					t2=0;
				if ( t == 0 && t1 == 0  && t2 == 255 && a==1){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==1)
					dst->imageData[ i*dst->width+j ]=0;//取紅色
				if ( t == 255 && t1 == 0  && t2 == 0 && a==2 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==2)
					dst->imageData[ i*dst->width+j ]=0;//取藍色
				if ( t == 0 && t1 == 255  && t2 == 0 && a==3 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==3)
					dst->imageData[ i*dst->width+j ]=0;//取綠色
				if ( t == 255 && t1 == 255  && t2 == 255 && a==4 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==4)
					dst->imageData[ i*dst->width+j ]=0;//取白色
		}
	}

	
	}
}
void judeg(IplImage *dst, double *x , double *y , double *z, double *side,double imagedistance, int choose)
{
	int edgeThresh = 50;
    IplImage *image;
    int IW1;
    int IL1;
    int vertex1X1=0;
    int vertex1Y1=0;
    int a=0;
    int vertex1X2=0;
    int vertex1Y2=0;
    int vertex1X3=0;
    int vertex1Y3=0;
	double center1X=0;
    double center1Y=0;
	double realmoveX=0;
	double realmoveY=0;
	double realmoveZ=0;
	double sidelength1=0;
	double scalevalue=0;
    double realobjectdistance = 34;
    double realobjectdistance1=0;
    image = cvCreateImage(cvSize(dst->width,dst->height),IPL_DEPTH_8U,1);
	cvDilate(dst,image,0,1);
	cvErode(image,image,0,1);
    cvThreshold(image,image,200,255,CV_THRESH_BINARY);
    cvCanny(image, image, edgeThresh, edgeThresh*3, 3);
	
	
	IW1=image->height;
	IL1=image->width;
    unsigned char **firstpicture = new unsigned char *[IW1];
    
	for(int i = 0 ; i< IW1 ; i++)
		firstpicture[i] = new unsigned char [IL1];
	for(int i = 0 ; i< IW1 ; i++)
	  for(int j = 0 ; j < IL1 ; j++)
		firstpicture[i][j] = (unsigned char) image->imageData[i*IL1+j];//讀取第一張圖片的陣列

	for(int i = 0 ; i< IW1 ; i++)
		for(int j = 0 ; j < IL1 ; j++){
			if((unsigned int)firstpicture[i][j] == 255 && a == 0){
				vertex1X1=j;
				vertex1Y1=i;
				a=1;
			}
		}
	for(int i = IW1-1 ; i > 0 ; i--)
		for(int j = 0 ; j < IL1 ; j++){ 
			if((unsigned int)firstpicture[i][j] == 255 && a == 1){
				vertex1X2=j;
				vertex1Y2=i;
				a=2;
			}
		}
	for(int j = IL1-1 ; j > 0 ; j--)
		for(int i = IW1-1 ; i > 0 ; i--){
			if((unsigned int)firstpicture[i][j] == 255 && a == 2){
				vertex1X3=j;
				vertex1Y3=i;
				a=3;
			}

		}
	double side1 = sqrt(pow(double(vertex1X3-vertex1X2),2)+pow(double(vertex1Y3-vertex1Y2),2));
	double side2 = sqrt(pow(double(vertex1X3-vertex1X1),2)+pow(double(vertex1Y3-vertex1Y1),2));
	double side3 = sqrt(pow(double(vertex1X1-vertex1X2),2)+pow(double(vertex1Y1-vertex1Y2),2));
	cout << side1 << "      " << side2 << "     " << side3 << "\n";
	if((side1-side2)<10 && (side1-side2)>-10 && (side2-side3)>-10 && (side2-side3)<10 && (side1-side3)>-10 && (side1-side2)<10)
	{  
        sidelength1 =  sqrt(pow(double(vertex1X3-vertex1X2),2)+pow(double(vertex1Y3-vertex1Y2),2));
	    if(choose==1)
		scalevalue = 8;
		else 
		scalevalue = 15;

		center1X = (vertex1X1+vertex1X2+vertex1X3)/3;
		center1Y = (vertex1Y1+vertex1Y2+vertex1Y3)/3;
		realmoveX=(IL1/2-center1X)/(sidelength1/scalevalue);
		realmoveY=(IW1/2-center1Y)/(sidelength1/scalevalue);
		cout << "重心:" << center1X << "," << center1Y << "\n"; 

	    realobjectdistance1=imagedistance*scalevalue/sidelength1;
	    realmoveZ=realobjectdistance-realobjectdistance1;
	
        *x=realmoveX;
        *y=realmoveY;
		*z=realmoveZ;
		*side=side1;
	}
	else
	{
		*x=0;
		*y=0;
		*z=0;
		*side=1;
	}
   
    for(int i=0; i<IW1 ;i++)
		delete firstpicture[i];
	delete firstpicture;
}
