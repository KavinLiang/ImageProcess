#include "highgui.h"
#include <cv.h>

void Float(IplImage *dst, double *x , double *y , double *z )
{   
    IplImage *image;
    int edgeThresh = 50;
    int IW1;
    int IL1;
    int vertex1X1=0;
    int vertex1Y1=0;
    int a=0;
    int A1=0;
    int vertex1X2=0;
    int vertex1Y2=0;
    int vertex1X3=0;
    int vertex1Y3=0;
    double center1X=0;
    double center1Y=0;
    double realobjectdistance = 60;
    double imagedistance = 0;
    double realobjectdistance1=0;
    image = cvCreateImage(cvSize(dst->width,dst->height),IPL_DEPTH_8U,1);
	cvDilate(dst,image,0,1);
	cvErode(image,image,0,1);
    cvThreshold(image,image,200,255,CV_THRESH_BINARY);
    cvCanny(image, image, edgeThresh, edgeThresh*3, 3);
	

	IW1=image->height;
	IL1=image->width;
	

    unsigned char **firstpicture = new unsigned char *[IW1];
	
    
	for(int i = 0 ; i< IW1 ; i++)
		firstpicture[i] = new unsigned char [IL1];
	for(int i = 0 ; i< IW1 ; i++)
	  for(int j = 0 ; j < IL1 ; j++)
		firstpicture[i][j] = (unsigned char) image->imageData[i*IL1+j];//讀取第一張圖片的陣列


	for(int i = 0 ; i< IW1 ; i++)
		for(int j = 0 ; j < IL1 ; j++){
			if((unsigned int)firstpicture[i][j] == 255 && a == 0){
				vertex1X1=j;
				vertex1Y1=i;
				a=1;
			}
		}
	std::cout << "第一個頂點:" << vertex1X1 << "," << vertex1Y1 << "\n";
	for(int i = IW1-1 ; i > 0 ; i--)
		for(int j = 0 ; j < IL1 ; j++){ 
			if((unsigned int)firstpicture[i][j] == 255 && a == 1){
				vertex1X2=j;
				vertex1Y2=i;
				a=2;
			}
		}
	std::cout << "第二個頂點:" << vertex1X2 << "," << vertex1Y2 << "\n";
	for(int j = IL1-1 ; j > 0 ; j--)
		for(int i = IW1-1 ; i > 0 ; i--){
			if((unsigned int)firstpicture[i][j] == 255 && a == 2){
				vertex1X3=j;
				vertex1Y3=i;
				a=3;
			}

		}
        double sidelength1 =  sqrt(pow(double(vertex1X3-vertex1X2),2)+pow(double(vertex1Y3-vertex1Y2),2));
	A1 = sqrt(double(3))*pow(sidelength1,2)/4;
	std::cout << "第三個頂點:" << vertex1X3 << "," << vertex1Y3 << "\n";
	center1X = (vertex1X1+vertex1X2+vertex1X3)/3;
	center1Y = (vertex1Y1+vertex1Y2+vertex1Y3)/3;
	std::cout << "重心:" << center1X << "," << center1Y << "\n"; 
	std::cout << "面積:" << A1 << std::endl;
        imagedistance=realobjectdistance*sidelength1/12;	
	std::cout << "\n影像與光感距離: " << imagedistance;
        *x=center1X;
        *y=center1Y;
        *z=0;
		delete firstpicture;
}
void separation2(IplImage *src, IplImage *dst, int a){
  //陣列方式宣告
	//unsigned char** R = new unsigned char *[src->height];	
	//unsigned char** G = new unsigned char *[src->height];
	//unsigned char** B = new unsigned char *[src->height];
	//for( int i = 0 ; i < src->height ; i++ ){
	//	R[i] = new unsigned char[src->width];
	//	G[i] = new unsigned char[src->width];
	//	B[i] = new unsigned char[src->width];
	//}
//指標方式宣告
	IplImage *R = cvCreateImage(cvGetSize(src),8,1);
	IplImage *G = cvCreateImage(cvGetSize(src),8,1);
	IplImage *B = cvCreateImage(cvGetSize(src),8,1);
	for( int i=0 ; i<src->height ; i++ ){
		int countR=0,countG=0,countB=0;
		for ( int j=0; j<src->widthStep ; j++ ){
			if	( j%3==2 ){
				R->imageData[i*R->width+countR]= src->imageData[i*src->widthStep+j];
				countR++;
			}
			if ( j%3==1 ){
				G->imageData[i*G->width+countG]= src->imageData[i*src->widthStep+j];
				countG++;
			}
			if ( j%3==0 ){
				B->imageData[i*B->width+countB]= src->imageData[i*src->widthStep+j];
				countB++;
			}
		}
	}
////RGB矩陣測試
//	for( int i=0 ; i<src->height ; i++ ){
//		for(int j=0 ; j<src->width ; j++){
//			unsigned char temp=B->imageData[i*B->width+j];
//			unsigned char temp1=G->imageData[i*G->width+j];
//			unsigned char temp2=R->imageData[i*R->width+j];
//			int t = temp;
//			int t1=temp1;
//			int t2=temp2;
//			
//			//std::cout<<t<<std::endl; 
//		}
//	}
	for( int i=0 ; i<dst->height ; i++ ){
		for( int j=0 ; j< dst->width ; j++ ){
				unsigned char temp=B->imageData[i*B->width+j];
				unsigned char temp1=G->imageData[i*G->width+j];
				unsigned char temp2=R->imageData[i*R->width+j];
				int t=temp;
				int t1=temp1;
				int t2=temp2;
				if(t>128)
					t=255;
				else
					t=0;
				if(t1>128)
					t1=255;
				else
					t1=0;
				if(t2>128)
					t2=255;
				else
					t2=0;
				if ( t == 0 && t1 == 0  && t2 == 255 && a==1){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==1)
					dst->imageData[ i*dst->width+j ]=0;
				if ( t == 255 && t1 == 0  && t2 == 0 && a==2 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==2)
					dst->imageData[ i*dst->width+j ]=0;
				if ( t == 0 && t1 == 255  && t2 == 0 && a==3 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==3)
					dst->imageData[ i*dst->width+j ]=0;
				if ( t == 255 && t1 == 255  && t2 == 255 && a==4 ){
					dst->imageData[ i*dst->width+j ] =255;
				}
				else if(a==4)
					dst->imageData[ i*dst->width+j ]=0;
		}
	}
}
int main()
{
IplImage *Img; 
IplImage *dst;

Img = cvLoadImage("123.jpg",1); 

int i, j, IW, IL;
double	*x,*y,*z;
int a=1;
IW = Img->height;
IL = Img->width;
dst= cvCreateImage( cvSize(IL ,IW) , 8, 1 );
for(i=0;i<4;i++){
separation2( Img , dst, a);
Float( dst, x, y, z);
a++;
}


//顯示影像
cvNamedWindow("Picture",1); 
cvShowImage("Picture",Img);
cvNamedWindow("Picture1",1); //建立視窗(視窗名稱,參數) 
cvShowImage("Picture1",dst); //顯示影像(視窗名稱,影像檔案) 
cvWaitKey(0); //按下任意按鍵可將圖片關閉
return 0;
}
